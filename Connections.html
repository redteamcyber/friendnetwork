<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Friend Network Graph</title>
  <style>
    /* ================================
      GLOBAL ‚Äî DARK MODE + BLUE ACCENTS
    =================================== */
    body {
      font-family: system-ui, sans-serif;
      background: #0d1117;          /* deep dark */
      color: #c9d1d9;               /* light gray text */
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }

    header {
      margin-bottom: 20px;
      text-align: center;
      color: #c9d1d9;
    }

    /* ================================
      LAYOUT
    =================================== */
    main {
      display: flex;
      width: 95%;
      max-width: 1400px;
      position: relative;
    }

    #controls {
      width: 350px;
      min-width: 200px;
      max-width: 600px;
      background: #161b22;          /* dark panel */
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.4);
      overflow-y: auto;
      max-height: 85vh;
      resize: none;
    }

    /* ================================
      RESIZE HANDLE
    =================================== */
    .resize-handle {
      width: 8px;
      background: #21262d;
      cursor: col-resize;
      flex-shrink: 0;
      position: relative;
      transition: background 0.2s;
    }

    .resize-handle:hover {
      background: #1f6feb; /* bright blue */
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #30363d;
      transform: translateX(-50%);
    }

    .resize-handle:hover::before {
      background: #58a6ff; /* soft blue */
    }

    /* ================================
      GRAPH AREA
    =================================== */
    #network-graph {
      flex: 1;
      min-width: 300px;
      height: 700px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }

    /* ================================
      FRIEND FORM
    =================================== */
    .friend-form {
      display: flex;
      margin-bottom: 20px;
      align-items: center;
      gap: 5px;
    }

    .friend-form input,
    .friend-form button {
      padding: 10px;
      border-radius: 6px;
      background: #0d1117;
      color: #c9d1d9;
      border: 1px solid #30363d;
    }

    .friend-form button#add-friend {
      background: #1f6feb;      /* primary blue */
      color: white;
      border: none;
      cursor: pointer;
    }

    .friend-form button#add-friend:hover {
      background: #1158c7;      /* darker blue */
    }

    /* ================================
      SIDEBAR LIST (TREE)
    =================================== */
    #tree-root {
      list-style: none;
      padding: 0;
    }

    .friend-item {
      margin-bottom: 1rem;
      background: #1c2128;        /* dark card */
      border: 1px solid #30363d;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    }

    /* Delete Friend Button (blue, not red) */
    .delete-btn {
      background: #dc2626;
      color: white;
      border: none;
      padding: 0.3rem 0.6rem;
      border-radius: 6px;
      cursor: pointer;
      float: right;
    }

    .delete-btn:hover {
      background: #b91c1c;
    }

    /* ================================
      CONNECTIONS LIST
    =================================== */
    .connections-list {
      margin-top: 0.5rem;
      padding-left: 1.2rem;
    }

    .connection-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #0d1117;
      border-radius: 6px;
      margin: 4px 0;
      padding: 4px 8px;
      border: 1px solid #30363d;
    }

    .connection-item button {
      background: #ad3333;
      border: none;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .connection-item button:hover {
      background: #ad3333;
    }

    /* ================================
      ADD CONNECTION FORM
    =================================== */
    .connection-form {
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .connection-form select,
    .connection-form button {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #c9d1d9;
      font-size: 0.9rem;
    }

    .connection-form button {
      background: #1f6feb;
      border: none;
      color: white;
    }

    .connection-form button:hover {
      background: #1158c7;
    }

    /* ================================
      D3 GRAPH STYLES
    =================================== */
    .link {
      stroke: #58a6ff;       /* glowing blue lines */
    }

    .node circle {
      fill: #1f6feb;
      cursor: pointer;
    }

    .node text {
      font-size: 10px;
      font-weight: bold;
      fill: #c9d1d9;
      pointer-events: none;
      text-anchor: middle;
      text-shadow: 0 0 2px #000;
    }
  </style>
</head>
<body>
  <header>
    <h1>üå≥ Friend Network Visualizer</h1>
    <p>Visualize the relationships in a force-directed graph.</p>
    <a href="firebase.html" style="
      display:inline-block;
      margin-top:10px;
      font-size:1rem;
      color:#1976D2;
      text-decoration:none;
      font-weight:bold;
    ">Go to Firebase Page</a>
  </header>

  <main>
    <div id="controls">
        <h2>Add Friend</h2>
        <section class="friend-form">
            <input type="text" id="name-input" placeholder="Enter name">
            <button id="add-friend">Add Friend</button>
        </section>

        <h2>Friend List & Connections</h2>
        <section id="friend-tree">
            <ul id="tree-root"></ul>
        </section>
    </div>

    <div class="resize-handle" id="resize-handle"></div>

    <section id="network-graph">
        <svg></svg>
    </section>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
    import { getDatabase, ref, set, get, push, update, remove, child } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
    // Use an ES-module-compatible build of d3 so d3.select works in modules
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const firebaseConfig = {
      apiKey: "AIzaSyCRNRlGcGNNT_s6Io1I5KTlzWnAh6SQOaI",
      authDomain: "friendnetwork-862ab.firebaseapp.com",
      databaseURL: "https://friendnetwork-862ab-default-rtdb.firebaseio.com",
      projectId: "friendnetwork-862ab",
      storageBucket: "friendnetwork-862ab.firebasestorage.app",
      messagingSenderId: "63599209189",
      appId: "1:63599209189:web:d319fd76397014f97d820c",
      measurementId: "G-E05JH3NEYY"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const nameInput = document.getElementById("name-input");
    const addBtn = document.getElementById("add-friend");
    const treeRoot = document.getElementById("tree-root");
    const graphContainer = document.getElementById("network-graph");
    const controlsPanel = document.getElementById("controls");
    const resizeHandle = document.getElementById("resize-handle");

    // Resize handle functionality
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = controlsPanel.offsetWidth;
      document.addEventListener('mousemove', handleResize);
      document.addEventListener('mouseup', stopResize);
      e.preventDefault();
    });

    function handleResize(e) {
      if (!isResizing) return;
      const width = startWidth + (e.clientX - startX);
      const minWidth = 200;
      const maxWidth = 600;
      const newWidth = Math.max(minWidth, Math.min(maxWidth, width));
      controlsPanel.style.width = newWidth + 'px';
    }

    function stopResize() {
      isResizing = false;
      document.removeEventListener('mousemove', handleResize);
      document.removeEventListener('mouseup', stopResize);
      // Update graph size after resize
      const svg = d3.select(graphContainer).select('svg');
      if (!svg.empty()) {
        const width = graphContainer.clientWidth;
        const height = graphContainer.clientHeight;
        svg.attr('width', width).attr('height', height);
      }
    }

    function drag(simulation) {
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
      return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }

    function renderGraph(friends) {
      console.log("Rendering graph with friends:", friends); // Debug log
      
      const nodes = [];
      const links = [];
      const friendMap = {};

      // Create nodes for all friends
      for (const [id, friend] of Object.entries(friends)) {
        if (!friend || !friend.name) continue; // Skip invalid entries
        friendMap[id] = nodes.length;
        nodes.push({ id, name: friend.name });
      }

      console.log("Created nodes:", nodes.length); // Debug log

      // Create links for connections
      const linkSet = new Set(); 
      for (const [sourceId, friend] of Object.entries(friends)) {
        if (!friend || !friend.connections) continue;
        for (const targetId of friend.connections) {
          if (!friends[targetId]) continue; // Skip if target doesn't exist
          const smaller = sourceId < targetId ? sourceId : targetId;
          const larger = sourceId < targetId ? targetId : sourceId;
          const key = `${smaller}-${larger}`;
          if (!linkSet.has(key) && friendMap[targetId] !== undefined && friendMap[sourceId] !== undefined) {
            links.push({ source: sourceId, target: targetId });
            linkSet.add(key);
          }
        }
      }

      console.log("Created links:", links.length); // Debug log

      graphContainer.innerHTML = '';
      const width = graphContainer.clientWidth || 800;
      const height = graphContainer.clientHeight || 700;

      const svg = d3.select(graphContainer)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const g = svg.append("g");

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(120))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(25))
        .on("tick", ticked);

      const link = g.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("class", "link")
        .attr("stroke-width", 2)
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6);

      const node = g.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .call(drag(simulation));

      node.append("circle")
        .attr("r", 20)
        .attr("fill", "#4CAF50")
        .attr("stroke", "#fff")
        .attr("stroke-width", 2);

      node.append("text")
        .attr("dy", 5)
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("fill", "#333")
        .text(d => d.name);

      function ticked() {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      }

      svg.call(
        d3.zoom()
          .extent([[0, 0], [width, height]])
          .scaleExtent([0.5, 8])
          .on("zoom", ({transform}) => {
            g.attr("transform", transform);
          })
      );
    }

    async function addFriend() {
      const name = nameInput.value.trim();
      if (!name) return alert("Please enter a name.");
      const newRef = push(ref(db, "Friends"));
      await set(newRef, { name, connections: [] });
      nameInput.value = "";
      loadFriends();
    }

    async function deleteFriendById(id, name) {
      if (!confirm(`Delete "${name}"?`)) return;
      await remove(ref(db, "Friends/" + id));
      await cleanConnections(id);
      loadFriends();
    }

    async function cleanConnections(deletedId) {
      const dbRef = ref(db);
      const snapshot = await get(child(dbRef, "Friends"));
      if (!snapshot.exists()) return;
      const allFriends = snapshot.val();
      for (const [id, friend] of Object.entries(allFriends)) {
        if (friend.connections?.includes(deletedId)) {
          const updated = friend.connections.filter(c => c !== deletedId);
          await update(ref(db, "Friends/" + id), { connections: updated });
        }
      }
    }

    async function deleteConnectionBetween(aId, bId) {
      const dbRef = ref(db);
      const snapshot = await get(child(dbRef, "Friends"));
      if (!snapshot.exists()) return;
      const data = snapshot.val();
      const aConnections = new Set(data[aId]?.connections || []);
      const bConnections = new Set(data[bId]?.connections || []);
      aConnections.delete(bId);
      bConnections.delete(aId);
      await update(ref(db, "Friends/" + aId), { connections: [...aConnections] });
      await update(ref(db, "Friends/" + bId), { connections: [...bConnections] });
      loadFriends();
    }

    async function addConnectionBetween(aId, bId) {
      const dbRef = ref(db);
      const snapshot = await get(child(dbRef, "Friends"));
      if (!snapshot.exists()) return alert("No users found.");
      const allFriends = snapshot.val();
      const aConnections = new Set(allFriends[aId]?.connections || []);
      const bConnections = new Set(allFriends[bId]?.connections || []);
      aConnections.add(bId);
      bConnections.add(aId);
      await update(ref(db, "Friends/" + aId), { connections: [...aConnections] });
      await update(ref(db, "Friends/" + bId), { connections: [...bConnections] });
      loadFriends();
    }

    async function loadFriends() {
      try {
        console.log("loadFriends called"); // Debug
        const dbRef = ref(db);
        const snapshot = await get(child(dbRef, "Friends"));
        console.log("Snapshot exists:", snapshot.exists()); // Debug
        
        const friendTreeSection = document.getElementById("friend-tree");
        if (!friendTreeSection) {
          console.error("friend-tree section not found!");
          return;
        }
        
        friendTreeSection.innerHTML = '<ul id="tree-root"></ul>';
        // Get reference to the newly created tree-root
        const currentTreeRoot = document.getElementById("tree-root");
        if (!currentTreeRoot) {
          console.error("tree-root not found!");
          return;
        }
        currentTreeRoot.innerHTML = "";
        let friends = {};

      if (!snapshot.exists()) {
        currentTreeRoot.innerHTML = "<li>No friends yet.</li>";
        renderGraph({});
        return;
      }

      friends = snapshot.val();
      console.log("Loaded friends:", friends); // Debug log
      console.log("Number of friends:", friends ? Object.keys(friends).length : 0);
      
      // Ensure we have friends data
      if (!friends || Object.keys(friends).length === 0) {
        currentTreeRoot.innerHTML = "<li>No friends found in database.</li>";
        renderGraph({});
        return;
      }
      
      // Clean up invalid connections (only remove connections to friends that don't exist)
      let needsReload = false;
      for (const [id, friend] of Object.entries(friends)) {
        if (!friend.connections || friend.connections.length === 0) continue;
        const validConnections = [];
        for (const connId of friend.connections) {
          // Only remove connection if target friend doesn't exist
          // Keep one-way connections - they're valid
          if (friends[connId]) {
            validConnections.push(connId);
          }
        }
        // Update if we found invalid connections (to non-existent friends)
        if (validConnections.length !== friend.connections.length) {
          await update(ref(db, "Friends/" + id), { connections: validConnections });
          friend.connections = validConnections;
          needsReload = true;
        }
      }
      
      // Reload if we cleaned up connections to get fresh data
      if (needsReload) {
        const updatedSnapshot = await get(child(dbRef, "Friends"));
        if (updatedSnapshot.exists()) {
          friends = updatedSnapshot.val();
        }
      }
      
      // Add summary header before the list
      const summaryDiv = document.createElement("div");
      summaryDiv.style.cssText = "margin-bottom: 1rem; padding: 0.75rem; background: #e3f2fd; border-radius: 8px; font-size: 0.9rem;";
      summaryDiv.innerHTML = `<strong>üë• Total Friends: ${Object.keys(friends).length}</strong>`;
      friendTreeSection.insertBefore(summaryDiv, currentTreeRoot);
      
      // Create a visual list showing all friends and their connections
      console.log("Creating friend list items...");
      let friendCount = 0;
      for (const [id, friend] of Object.entries(friends)) {
        if (!friend || !friend.name) {
          console.warn("Invalid friend data:", id, friend);
          continue;
        }
        friendCount++;
        const li = document.createElement("li");
        li.className = "friend-item";
        const header = document.createElement("div");
        header.innerHTML = `
          <button class="delete-btn" data-id="${id}" data-name="${friend.name}">üóëÔ∏è</button>
          <strong>${friend.name}</strong>
        `;
        li.appendChild(header);
        
        const connList = document.createElement("ul");
        connList.className = "connections-list";
        const connections = friend.connections || [];
        
        // Show all connections where the target friend exists
        const validConnections = connections.filter(connId => {
          return friends[connId] !== undefined;
        });
        
        if (validConnections.length > 0) {
          connList.innerHTML = '<li style="font-size: 0.8rem; color: #666; margin-bottom: 0.5rem;">Connected to:</li>';
          for (const connId of validConnections) {
            const connItem = document.createElement("li");
            connItem.className = "connection-item";
            const connName = friends[connId].name;
            // Check if connection is mutual
            const isMutual = friends[connId].connections?.includes(id);
            const connectionIcon = isMutual ? '‚ÜîÔ∏è' : '‚Üí';
            const connectionStatus = isMutual ? '' : ' (one-way)';
            connItem.innerHTML = `
              <span>${connectionIcon} ${connName}${connectionStatus}</span>
              <button data-a="${id}" data-b="${connId}">‚ùå</button>
            `;
            connItem.querySelector("button").addEventListener("click", e => {
              deleteConnectionBetween(id, connId);
            });
            connList.appendChild(connItem);
          }
        } else {
          connList.innerHTML = `<li style="font-size: 0.85rem; color: #999;"><em>No connections yet</em></li>`;
        }
        li.appendChild(connList);

        // Show friends who aren't already in this friend's connections list
        const availableFriends = Object.entries(friends)
          .filter(([fid]) => {
            if (fid === id) return false;
            // Show if not already connected (regardless of mutual status)
            return !connections.includes(fid);
          });
        if (availableFriends.length > 0) {
          const connForm = document.createElement("div");
          connForm.className = "connection-form";
          const select = document.createElement("select");
          for (const [fid, fdata] of availableFriends) {
            const option = document.createElement("option");
            option.value = fid;
            option.textContent = fdata.name;
            select.appendChild(option);
          }
          const addBtn = document.createElement("button");
          addBtn.textContent = "‚ûï Add Connection";
          addBtn.addEventListener("click", () => addConnectionBetween(id, select.value));
          connForm.appendChild(select);
          connForm.appendChild(addBtn);
          li.appendChild(connForm);
        }
        header.querySelector(".delete-btn").addEventListener("click", e => {
          deleteFriendById(id, friend.name);
        });
        currentTreeRoot.appendChild(li);
      }
      console.log(`Added ${friendCount} friends to the list`);
      console.log("Rendering graph with", Object.keys(friends).length, "friends");
      renderGraph(friends);
      } catch (error) {
        console.error("Error loading friends:", error);
        const friendTreeSection = document.getElementById("friend-tree");
        if (friendTreeSection) {
          friendTreeSection.innerHTML = `<div style="color: red; padding: 1rem;">Error loading friends: ${error.message}</div>`;
        }
      }
    }

    addBtn.addEventListener("click", addFriend);
    
    // Load friends when page loads
    if (document.readyState === 'loading') {
      window.addEventListener("load", loadFriends);
    } else {
      // DOM already loaded
      loadFriends();
    }
  </script>
</body>
</html>